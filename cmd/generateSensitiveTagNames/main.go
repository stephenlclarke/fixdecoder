package main

// cmd/generateSensitiveTagNames/main.go
//
// Scans <repo-root>/resources/*.xml for FIX <field> definitions whose "name"
// suggests sensitive identity/credential info, then generates
// fix/sensitiveTagNames_gen.go containing:
//
//   package fix
//   // Code generated by generateSensitiveTagNames; DO NOT EDIT.
//   var SensitiveTagNames = map[int]string{ ... }
//
// Run from anywhere:
//
//   go run ./cmd/generateSensitiveTagNames/main.go
//
// Patterns considered sensitive (case-insensitive):
//   CompID, SubID, LocationID, Username, Password, Account
//
// Notes:
// - We locate the repo root by walking upward until we find go.mod or a
//   "resources" directory. This makes the tool resilient to where it's run.
// - We parse FIX dictionaries that have a <fields><field .../></fields> shape.

import (
	"bytes"
	"encoding/xml"
	"errors"
	"fmt"
	"go/format"
	"io"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
)

// For testing/mocking:
var formatSource = format.Source
var filepathGlob = filepath.Glob

func main() {
	if err := run(); err != nil {
		fmt.Fprintf(os.Stderr, "generatedSensitiveTagNames: %v\n", err)
		os.Exit(1)
	}
}

func run() error {
	repoRoot, err := findRepoRoot()
	if err != nil {
		return fmt.Errorf("cannot locate repo root: %w", err)
	}

	resDir := filepath.Join(repoRoot, "resources")
	if fi, err := os.Stat(resDir); err != nil || !fi.IsDir() {
		return fmt.Errorf("resources directory not found at %q", resDir)
	}

	xmlPaths, err := filepathGlob(filepath.Join(resDir, "*.xml"))
	if err != nil {
		return fmt.Errorf("glob resources: %w", err)
	}
	if len(xmlPaths) == 0 {
		return fmt.Errorf("no FIX XML files in %q", resDir)
	}

	fields, err := loadAllFields(xmlPaths)
	if err != nil {
		return err
	}

	sensitive := filterSensitive(fields)
	if len(sensitive) == 0 {
		return errors.New("no sensitive tags found (check patterns and resources)")
	}

	genPath := filepath.Join(repoRoot, "fix", "sensitiveTagNames.go")
	if err := writeGeneratedFile(genPath, sensitive); err != nil {
		return err
	}

	fmt.Printf("Generated %s with %d tags\n", relOrSame(genPath, repoRoot), len(sensitive))
	return nil
}

func findRepoRoot() (string, error) {
	start, err := os.Getwd()
	if err != nil {
		return "", err
	}
	dir := start
	for {
		if exists(filepath.Join(dir, "go.mod")) || isDir(filepath.Join(dir, "resources")) {
			return dir, nil
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			break
		}
		dir = parent
	}
	return "", fmt.Errorf("could not find go.mod or resources/ starting at %q", start)
}

func exists(path string) bool {
	_, err := os.Stat(path)
	return err == nil
}

func isDir(path string) bool {
	fi, err := os.Stat(path)
	return err == nil && fi.IsDir()
}

// ---- FIX XML parsing ----

type fixFieldsRoot struct {
	XMLName xml.Name   `xml:"fix"`
	Fields  []fixField `xml:"fields>field"`
}

type fixField struct {
	Number int    `xml:"number,attr"`
	Name   string `xml:"name,attr"`
	Type   string `xml:"type,attr"`
}

func loadAllFields(paths []string) (map[int]string, error) {
	out := make(map[int]string, 512)
	for _, p := range paths {
		m, err := parseFixXML(p)
		if err != nil {
			return nil, fmt.Errorf("parse %s: %w", p, err)
		}
		for k, v := range m {
			// first win keeps canonical name if duplicates appear
			if _, ok := out[k]; !ok {
				out[k] = v
			}
		}
	}
	return out, nil
}

func parseFixXML(path string) (map[int]string, error) {
	f, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	var root fixFieldsRoot
	dec := xml.NewDecoder(f)
	if err := dec.Decode(&root); err != nil {
		return nil, err
	}
	m := make(map[int]string, len(root.Fields))
	for _, fld := range root.Fields {
		if fld.Number > 0 && fld.Name != "" {
			m[fld.Number] = fld.Name
		}
	}
	return m, nil
}

// ---- Sensitive filtering ----

func filterSensitive(all map[int]string) map[int]string {
	// Case-insensitive match of any of these tokens in the field Name.
	pat := regexp.MustCompile(`(?i)(CompID|SubID|LocationID|Username|Password|Account)`)
	out := make(map[int]string, 64)
	for tag, name := range all {
		if pat.MatchString(name) {
			out[tag] = name
		}
	}
	return out
}

// ---- Code generation ----

func writeGeneratedFile(path string, tags map[int]string) error {
	var buf bytes.Buffer

	writeHeader(&buf)
	writeMap(&buf, tags)

	src, err := formatSource(buf.Bytes())
	if err != nil {
		// If formatting fails, write unformatted content to help debugging.
		src = buf.Bytes()
	}

	if err := os.MkdirAll(filepath.Dir(path), 0o755); err != nil {
		return fmt.Errorf("mkdir %s: %w", filepath.Dir(path), err)
	}
	tmp := path + ".tmp"
	if err := os.WriteFile(tmp, src, 0o644); err != nil {
		return fmt.Errorf("write temp: %w", err)
	}
	return os.Rename(tmp, path)
}

func writeHeader(w io.Writer) {
	fmt.Fprintln(w, "package fix")
	fmt.Fprintln(w)
	fmt.Fprintln(w, "// Code generated by generateSensitiveTagNames; DO NOT EDIT.")
	fmt.Fprintln(w, "// Source: resources/*.xml")
	fmt.Fprintln(w)
}

func writeMap(w io.Writer, tags map[int]string) {
	fmt.Fprintln(w, "var SensitiveTagNames = map[int]string{")

	// stable order for reproducible diffs
	type kv struct {
		Tag  int
		Name string
	}
	list := make([]kv, 0, len(tags))
	for t, n := range tags {
		list = append(list, kv{Tag: t, Name: n})
	}
	sort.Slice(list, func(i, j int) bool { return list[i].Tag < list[j].Tag })

	for _, e := range list {
		fmt.Fprintf(w, "\t%d: %q,\n", e.Tag, e.Name)
	}
	fmt.Fprintln(w, "}")
}

// ---- Helpers ----

func relOrSame(path, root string) string {
	if rel, err := filepath.Rel(root, path); err == nil && !strings.HasPrefix(rel, "..") {
		return rel
	}
	return path
}
